# Top-level configuration for CODEX pipeline
exp_id: default
sample_id: default

# -----------------------------------------------------------------------------
# (A) Data Source and Basic Image Settings
# -----------------------------------------------------------------------------
data:
  # Path to the main .qptiff or .tiff file for the CODEX image
  file_name: NW_Ovary_16/Scan1/NW_1_Scan1.qptiff
  
  # Path to the TSV file containing antibody definitions (one row per channel)
  antibodies_file: NW_Ovary_16/Scan1/extras/antibodies.tsv
  
  # Microns per pixel for this image; used in downstream calculations (e.g., segmentation scaling)
  image_mpp: 0.5
  
  # Whether to compute and save channel-level statistics (min, max, 95th percentile, etc.)
  generate_channel_stats: True

# -----------------------------------------------------------------------------
# (B) Channel Configuration
# -----------------------------------------------------------------------------
channels:
  # Name of the nuclear marker channel (must match an entry in the antibodies file)
  nuclear_channel: DAPI
  
  # Name(s) of the whole-cell marker channel(s). If multiple, they will be merged.
  wholecell_channel: 
  - Pan-Cytokeratin

# -----------------------------------------------------------------------------
# (C) Patch Extraction Parameters
# -----------------------------------------------------------------------------
patching:
  # Split mode can be "full_image", "halves", "quarters", or "patches"
  split_mode: full_image
  
  # Split direction can be "vertical" or "horizontal"
  split_direction: NULL

  # Size (height, width) of each patch (in pixels)
  patch_height: -1
  patch_width: -1
  
  # Overlap fraction between adjacent patches (0.1 means 10% overlap)
  overlap: 0.1

# -----------------------------------------------------------------------------
# (D) Visualization Settings
# -----------------------------------------------------------------------------
visualization:
  # Whether to save RGB visualizations of all patches
  visualize_patches: True

  # Whether to keep a temporary compressed cache of the full multi-channel patches for reuse
  cache_all_channel_patches: True

  # Whether to save the raw multi-channel patches to disk at the end of the run
  save_all_channel_patches: False

  # Number of threads to use when compressing all-channel patches (0=auto, -1=all cores)
  all_channel_compression_threads: 0

  # Whether to visualize and save the segmentation mask overlay (after segmentation)
  visualize_segmentation: True

# -----------------------------------------------------------------------------
# (D.2) HTML Report Settings
# -----------------------------------------------------------------------------
report:
  # Whether to compress images in the HTML report (resize and convert to JPEG)
  # Reduces typical report size from ~100MB to ~15-20MB
  compress_images: True

  # Maximum width in pixels for embedded images (maintains aspect ratio)
  # Smaller values = smaller file size but lower resolution
  image_max_width: 1200

  # JPEG quality for embedded images (1-100, higher = better quality but larger)
  # 85 is a good balance of quality and file size
  image_jpeg_quality: 85

  # Whether to include pre-repair comparison images (before/after segmentation repair)
  # Set to False to reduce report size by ~40% (loses repair diagnostics)
  include_pre_repair_images: True

# -----------------------------------------------------------------------------
# (E) QC (Patch-Level Quality Control)
# -----------------------------------------------------------------------------
patch_qc:
  # Minimum fraction of non-zero pixels required for a patch to be considered valid
  non_zero_perc_threshold: 0.05
  
  # Minimum mean intensity for the patch to be considered informative
  mean_intensity_threshold: 1.0
  
  # Minimum standard deviation required to avoid marking patches as too "flat"
  std_intensity_threshold: 1.0

# -----------------------------------------------------------------------------
# (F) Segmentation Parameters and Output Options
# -----------------------------------------------------------------------------
segmentation:
  # Path to the segmentation model directory (e.g., for DeepCell or another tool)
  model_path: /workspaces/codex-analysis/data/deepcell/v7/MultiplexSegmentation

  # If True, save segmentation masks as images
  save_segmentation_images: True

  # If True, pickle the entire codex_patches object (containing segmentation results, etc.)
  save_segmentation_pickle: True
  segmentation_pickle_compression: zstd      # options: none|gzip|bz2|lzma|zstd
  segmentation_pickle_compression_level: 5   # optional, honours backend limits
  segmentation_pickle_compression_threads: 0   # 0=auto, -1=all cores
  # If True, run segmentation analysis
  # Calculate metrics based on the segmentation results to describe the data quality
  segmentation_analysis: False
  density_analysis:
    calculate_global_density: False
    calculate_local_density: False

  # Mask repair configuration (cell-nucleus matching and repair)
  repair:
    # Enable GPU acceleration for mask repair operations (Phase 3 with vectorized matching)
    # Phase 3 provides 10-20x speedup for mismatch computation and matching on large samples
    # - GPU morphology: 10-50x speedup for boundary detection
    # - GPU overlap: 3-6x speedup for overlap matrix computation (Phase 4)
    # - GPU overlap bincount: 400-540x speedup (Phase 5c, recommended for >100K cells)
    # - GPU mismatch (Phase 3): 100-1000x speedup via vectorized boolean operations
    # Requires CuPy and CUDA-compatible GPU. Falls back to CPU if GPU unavailable.
    use_gpu: true

    # Phase 5c: Use bincount approach for overlap computation (400-540x speedup)
    # When True: tries bincount first, falls back to Phase 4 if needed
    # When False: uses Phase 4 sequential approach (baseline)
    # Recommended: True for samples with >100K cells
    # Phase 5c benefits: 54 min → 6-8 sec on D18_0 (1.99M cells)
    use_bincount_overlap: true

    # Batch size for GPU overlap computation (null = auto-size based on GPU memory)
    # Manual override useful for GPU memory constrained environments
    # Auto-sizing estimates based on mask dimensions and available VRAM
    # Only used for Phase 4 fallback (Phase 5c auto-manages memory)
    gpu_batch_size: null

    # Batch size for GPU mismatch computation (null = auto-size, 10000 = default)
    # Phase 3 feature: controls how many cell-nucleus pairs to process per GPU batch
    # Larger batches = faster but more GPU memory. Typical: 5K-50K pairs per batch.
    gpu_mismatch_batch_size: null

    # Number of GPUs to use for overlap computation (Stage 3)
    # Set to 2 to distribute work across 2 GPUs in parallel (~2x speedup)
    # - Phase 5c: distributes chunks across GPUs
    # - Phase 4: distributes cells across GPUs (cell-level round-robin)
    # Requires multiple CUDA-compatible GPUs. Falls back to single GPU if unavailable.
    overlap_num_gpus: 2

    # Number of GPUs to use for mismatch computation (Stage 4)
    # Set to 2 to distribute batches across 2 GPUs in parallel (1.87x speedup)
    # Saves ~12 min per sample on large datasets (>150K overlapping pairs)
    # Requires multiple CUDA-compatible GPUs. Falls back to single GPU if unavailable.
    mismatch_num_gpus: 2

    # Automatically fallback to CPU if GPU errors occur
    # Recommended to keep enabled for robustness
    # Fallback chain: Phase 5c → Phase 4 → CPU
    fallback_to_cpu: true

    # Log detailed GPU performance metrics (timing, speedup, memory usage)
    # Useful for performance analysis and optimization
    log_gpu_performance: true
  

# -----------------------------------------------------------------------------
# (G) Testing Data Disruption (Optional) 
#     If you do not want to disrupt your data, set "type" to null or remove this block.
# -----------------------------------------------------------------------------
testing:
  data_disruption:
    # Disruption type can be "downsampling" or "gaussian"
    type: NULL
    
    # Intensity level of disruption (1-5, for instance)
    level: -1.0
    
    # Whether to save the disrupted patches to disk (for debugging/testing)
    save_disrupted_patches: False  

    # Whether to visualize the disrupted patches
    visualize_disrupted: False

# -----------------------------------------------------------------------------
# (H) Evaluation Metrics
# -----------------------------------------------------------------------------
evaluation:
  compute_metrics: False

# -----------------------------------------------------------------------------
# (I) Profiling Feature Flags
# -----------------------------------------------------------------------------
profiling:
  features:
    # Compute per-channel Laplacian variance (expensive); disable to speed up profiling.
    compute_laplacian: False

    # Compute per-channel coefficient of variation; disable to save time.
    compute_cov: False

    # Dtype for per-channel intensity calculations; float32 reduces memory/compute.
    channel_dtype: float32

    # GPU acceleration for bincount operations (requires CuPy and CUDA-compatible GPU)
    # Provides 10-20x speedup for large samples (>1M cells)
    # Automatically falls back to CPU if GPU unavailable
    use_gpu: True

    # GPU batch size (number of channels to process at once on GPU)
    # Set to 0 for automatic detection based on available VRAM
    # Larger batches are faster but require more GPU memory
    gpu_batch_size: 0

    # GPU image processing mode for cell profiling (NEW)
    # Controls how image data is transferred to GPU for channel intensity computation
    # - "auto": Select based on available VRAM (recommended)
    #   If >40GB free: uses full_gpu mode (fastest)
    #   Otherwise: uses chw_cpu mode (still 100x faster than legacy)
    # - "full_gpu": Transfer entire (H,W,C) image to GPU once (~60s)
    #   GPU slicing is ~100x faster than CPU slicing
    #   Requires ~40GB VRAM for typical large samples
    # - "chw_cpu": Pre-convert to channel-first format in RAM (~45s)
    #   Slices are contiguous, enabling fast GPU transfer
    #   Requires ~54GB peak RAM during conversion
    # - "legacy": Per-channel transfer with image_dict (slowest)
    #   Use only for backward compatibility testing
    gpu_image_mode: auto

    # Regionprops caching for faster testing/development (NEW)
    # Caches nucleus and cell morphology properties to Parquet files
    # Saves ~16 min per sample (6 min nucleus + 10 min cell regionprops)
    # Cache key includes mask dimensions and content hash for invalidation
    cache_regionprops: false

    # Custom cache directory for regionprops (null = out_dir/cache/regionprops)
    regionprops_cache_dir: null
