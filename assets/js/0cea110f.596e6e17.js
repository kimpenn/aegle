"use strict";(self.webpackChunkaegle_docs=self.webpackChunkaegle_docs||[]).push([[4466],{276:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>r});const s=JSON.parse('{"id":"Main/SegmentationDetails","title":"Segmentation Details","description":"This document provides detailed information about the segmentation process, which is the implmenetation of runcellsegmentation in segment.py.","source":"@site/docs/Main/SegmentationDetails.md","sourceDirName":"Main","slug":"/Main/SegmentationDetails","permalink":"/aegle/docs/Main/SegmentationDetails","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Main/SegmentationDetails.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Configuration Reference","permalink":"/aegle/docs/Main/Configuration"},"next":{"title":"Evaluation Details","permalink":"/aegle/docs/Main/EvaluationDetails"}}');var i=t(4848),a=t(8453);const o={sidebar_position:5},c="Segmentation Details",l={},r=[{value:"Segmentation Workflow",id:"segmentation-workflow",level:2},{value:"Technical Details",id:"technical-details",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"segmentation-details",children:"Segmentation Details"})}),"\n",(0,i.jsxs)(n.p,{children:["This document provides detailed information about the segmentation process, which is the implmenetation of ",(0,i.jsx)(n.code,{children:"run_cell_segmentation"})," in ",(0,i.jsx)(n.code,{children:"segment.py"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"segmentation-workflow",children:"Segmentation Workflow"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"run_cell_segmentation"})," function orchestrates the entire segmentation process:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Patch Selection"}),": Only processes patches marked as informative (not empty or noisy) from Phase B"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Model Loading"}),": Loads the pre-trained DeepCell Mesmer model for multiplex segmentation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Segmentation Processing"}),": Applies the model to extract cell and nucleus masks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mask Repair"}),": Matches cells to nuclei and repairs segmentation artifacts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Result Storage"}),": Saves segmentation masks and metadata"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"technical-details",children:"Technical Details"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"run_cell_segmentation"})," function only processes patches marked as informative (not empty or noisy) from Phase B. The informative patches are marked as ",(0,i.jsx)(n.code,{children:"is_informative"})," in ",(0,i.jsx)(n.code,{children:"patches_metadata"}),". We prepare ",(0,i.jsx)(n.code,{children:"valid_patches"})," from this step. The patches can be in memory or on disk based on the ",(0,i.jsx)(n.code,{children:"split_mode"})," in the config. If the patches are on disk, we will only keep the indices of the informative patches since all the patches cannot fit into memory. If the patches are in memory, we will keep the patches in memory and save its reference in ",(0,i.jsx)(n.code,{children:"codex_patches.valid_patches"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The next step is to apply segmentation model to the patches. If the patches are on disk, we will iterate over the indices of the informative patches and load the patches from disk one by one. If the patches are in memory, we will pass patches to segmentation model in a batch."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"The iterative calling segmentation model for disked patches might be suboptimal in terms of speed. We could improve this by loading pathces in a batch and call the segmentation. Apply all the patches into Segmentation model may also exhust all the G-RAM. For now, we use memory map to save G-RAM. So in the future, we should consider a better strategy to handle this step. To achieve this, we need to compile a dataset with different size of images to explore different scenarios in terms of number of patches and patch size."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The segmentation is implmented in the ",(0,i.jsx)(n.code,{children:"segment"})," function. It calls the ",(0,i.jsx)(n.code,{children:"Mesmer"})," model to segment the patches. The ",(0,i.jsx)(n.code,{children:"Mesmer"})," model is a pre-trained model that can be found in ",(0,i.jsx)(n.code,{children:"deepcell.applications"}),". The ",(0,i.jsx)(n.code,{children:"segment"})," function is implemented in ",(0,i.jsx)(n.code,{children:"segment.py"}),". The function call is like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'    segmentation_predictions = model.predict(\n        valid_patches, image_mpp=image_mpp, compartment="both"\n    )\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The expected size of ",(0,i.jsx)(n.code,{children:"valid_patches"})," is ",(0,i.jsx)(n.code,{children:"(n_patches, height, width, 2)"}),". The first channel is the nucleus channel and the second channel is the whole cell channel. The ",(0,i.jsx)(n.code,{children:"image_mpp"})," is the microns per pixel of the image. The ",(0,i.jsx)(n.code,{children:"compartment"})," is the compartment to segment. It can be ",(0,i.jsx)(n.code,{children:'"whole-cell"'}),", ",(0,i.jsx)(n.code,{children:'"nuclear"'}),", or ",(0,i.jsx)(n.code,{children:'"both"'}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["We use ",(0,i.jsx)(n.code,{children:"_separate_batch"})," function to separate the segmentation predictions into cell and nucleus masks. Then use ",(0,i.jsx)(n.code,{children:"get_boundary"})," function, which is based on ",(0,i.jsx)(n.code,{children:"skimage.segmentation.find_boundaries"})," to get the boundaries of the cell and nucleus masks. The output of ",(0,i.jsx)(n.code,{children:"segment"})," function is a list of dictionaries, each containing the cell and nucleus masks and the boundaries as shown below:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'    segmentation_output = [\n        {\n            "cell": cell_mask,\n            "nucleus": nucleus_mask,\n            "cell_boundary": cell_boundary,\n            "nucleus_boundary": nucleus_boundary,\n        }\n    ]\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The next part is to repair the masks. We use ",(0,i.jsx)(n.code,{children:"repair_masks_batch"})," function to repair the masks. The function is implemented in ",(0,i.jsx)(n.code,{children:"repair_masks.py"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"repair_masks_batch"})," function performs quality control by matching cells to their corresponding nuclei across all segmentation patches. For each patch, it extracts pixel coordinates for cells (including nuclei and cell membranes), then iteratively finds the best cell-nucleus pairs by minimizing mismatch fraction (nucleus pixels outside the cell interior). The function uses a repair strategy that retains partial matches when the nucleus partially overlaps with the cell, filtering out segmentation artifacts where cells and nuclei don't properly correspond. The output includes matched cell and nucleus masks, cytoplasm masks (cell minus nucleus), and quality metrics including matched fractions and detailed statistics, ensuring downstream analysis only uses properly validated cell-nucleus pairs."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"codex_patches.repaired_seg_res_batch\ncodex_patches.seg_res_batch\ncodex_patches.patches_metadata\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Both ",(0,i.jsx)(n.code,{children:"repaired_seg_res_batch"})," and ",(0,i.jsx)(n.code,{children:"seg_res_batch"})," are saved in ",(0,i.jsx)(n.code,{children:"codex_patches.save_seg_res()"})," as ",(0,i.jsx)(n.code,{children:"matched_seg_res_batch.pickle"})," and ",(0,i.jsx)(n.code,{children:"original_seg_res_batch.pickle"})," respectively. Metadata is also updated in disk in ",(0,i.jsx)(n.code,{children:"codex_patches.save_metadata()"})," as ",(0,i.jsx)(n.code,{children:"patches_metadata.csv"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(6540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);