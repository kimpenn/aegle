"use strict";(self.webpackChunkaegle_docs=self.webpackChunkaegle_docs||[]).push([[663],{779:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Main/SegmentationAnalysis","title":"Segmentation Analysis","description":"This document describes the segmentation analysis module implemented in the Aegle pipeline. The segmentation analysis provides comprehensive evaluation of cell and nucleus segmentation results, intensity distributions across cellular compartments, and spatial density metrics.","source":"@site/docs/Main/SegmentationAnalysis.md","sourceDirName":"Main","slug":"/Main/SegmentationAnalysis","permalink":"/aegle/docs/Main/SegmentationAnalysis","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Main/SegmentationAnalysis.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Preprocess","permalink":"/aegle/docs/Main/Preprocess"},"next":{"title":"Downstream Analysis","permalink":"/aegle/docs/category/downstream-analysis"}}');var t=s(4848),a=s(8453);const l={sidebar_position:3},r="Segmentation Analysis",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Components",id:"key-components",level:2},{value:"1. Mask Analysis",id:"1-mask-analysis",level:3},{value:"2. Intensity Analysis",id:"2-intensity-analysis",level:3},{value:"3. Spatial Density Analysis",id:"3-spatial-density-analysis",level:3},{value:"Usage",id:"usage",level:2},{value:"Input Requirements",id:"input-requirements",level:2},{value:"Output Files",id:"output-files",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Relationship to Other Modules",id:"relationship-to-other-modules",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"segmentation-analysis",children:"Segmentation Analysis"})}),"\n",(0,t.jsx)(n.p,{children:"This document describes the segmentation analysis module implemented in the Aegle pipeline. The segmentation analysis provides comprehensive evaluation of cell and nucleus segmentation results, intensity distributions across cellular compartments, and spatial density metrics."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The segmentation analysis module performs in-depth analysis on segmentation masks and intensity data to evaluate cell and nucleus segmentation quality, characterize marker intensity distributions, and quantify spatial density patterns. This module is particularly important for assessing the quality of the segmentation pipeline and for understanding the spatial organization of cells within the tissue."}),"\n",(0,t.jsx)(n.h2,{id:"key-components",children:"Key Components"}),"\n",(0,t.jsx)(n.h3,{id:"1-mask-analysis",children:"1. Mask Analysis"}),"\n",(0,t.jsx)(n.p,{children:"The module analyzes multiple types of segmentation masks:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Original cell mask"}),": Raw cell segmentation results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Original nucleus mask"}),": Raw nucleus segmentation results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Matched cell mask"}),": Cells successfully matched to nuclei"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Matched nucleus mask"}),": Nuclei successfully matched to cells"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unmatched nucleus mask"}),": Nuclei that could not be matched to cells"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-intensity-analysis",children:"2. Intensity Analysis"}),"\n",(0,t.jsx)(n.p,{children:"For each marker channel in the image, the module:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Calculates mean intensity per object for each mask type"}),"\n",(0,t.jsx)(n.li,{children:"Computes intensity statistics (mean, median, standard deviation)"}),"\n",(0,t.jsx)(n.li,{children:"Quantifies bias metrics comparing original and matched masks"}),"\n",(0,t.jsx)(n.li,{children:"Visualizes intensity distributions across different mask types"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-spatial-density-analysis",children:"3. Spatial Density Analysis"}),"\n",(0,t.jsx)(n.p,{children:"The module analyzes the spatial arrangement of cells by:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Computing global cell density metrics (objects per square mm)"}),"\n",(0,t.jsx)(n.li,{children:"Calculating local density metrics in moving windows"}),"\n",(0,t.jsx)(n.li,{children:"Generating density distribution visualizations"}),"\n",(0,t.jsx)(n.li,{children:"Comparing density metrics across different mask types"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsxs)(n.p,{children:["The segmentation analysis is automatically executed as part of the main pipeline when specified in the configuration. The primary entry point is the ",(0,t.jsx)(n.code,{children:"run_segmentation_analysis"})," function from the ",(0,t.jsx)(n.code,{children:"aegle.segmentation_analysis.segmentation_analysis"})," module:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from aegle.segmentation_analysis.segmentation_analysis import run_segmentation_analysis\n\n# Run segmentation analysis on codex_patches object\nrun_segmentation_analysis(codex_patches, config, args)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"input-requirements",children:"Input Requirements"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"codex_patches"}),": A ",(0,t.jsx)(n.code,{children:"CodexPatches"})," object containing:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"original_seg_res_batch"}),": Original segmentation masks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"repaired_seg_res_batch"}),": Repaired segmentation masks after cell-nucleus matching"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"all_channel_patches"}),": Image data across all channels"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"config"}),": Configuration dictionary with parameters for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Image resolution (microns per pixel)"}),"\n",(0,t.jsx)(n.li,{children:"Visualization settings"}),"\n",(0,t.jsx)(n.li,{children:"Analysis parameters"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"args"}),": Command-line arguments, primarily for output directory specification"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"output-files",children:"Output Files"}),"\n",(0,t.jsx)(n.p,{children:"Segmentation analysis generates the following outputs:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"codex_patches_segmentation_analysis.pickle"}),": Serialized analysis results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Channel intensity distribution plots"}),": Visualization of marker intensity distribution for each channel across different mask types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cell density visualizations"}),": Histograms and density plots of spatial density metrics"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Channel intensity bias analysis"}),": Comparison of intensity statistics between original and matched masks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Updated metadata"}),": The patch metadata is updated with density metrics"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(n.p,{children:["The intensity analysis is computationally intensive as it processes large arrays of pixel-level data. To improve performance, the module uses parallel processing via Python's ",(0,t.jsx)(n.code,{children:"ProcessPoolExecutor"})," for calculating mean intensities across different mask types. However, this can lead to high memory usage for large datasets."]}),"\n",(0,t.jsx)(n.p,{children:"For very large images, consider:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Processing fewer channels at a time"}),"\n",(0,t.jsx)(n.li,{children:"Reducing the number of parallel processes"}),"\n",(0,t.jsx)(n.li,{children:"Setting a limit on the number of objects analyzed"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If memory errors or process terminations occur, adjust the parallelization strategy or process smaller batches of data."}),"\n",(0,t.jsx)(n.h2,{id:"relationship-to-other-modules",children:"Relationship to Other Modules"}),"\n",(0,t.jsx)(n.p,{children:"The segmentation analysis module operates on the outputs of:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The cell segmentation module which produces the initial segmentation masks"}),"\n",(0,t.jsx)(n.li,{children:"The cell-nucleus matching algorithm which creates the matched masks"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Its outputs inform:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Quality assessment of the segmentation pipeline"}),"\n",(0,t.jsx)(n.li,{children:"Downstream cell profiling and phenotyping"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>r});var i=s(6540);const t={},a=i.createContext(t);function l(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);