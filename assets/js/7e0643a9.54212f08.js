"use strict";(self.webpackChunkaegle_docs=self.webpackChunkaegle_docs||[]).push([[204],{7336:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Preprocess/Preprocess","title":"Preprocess","description":"This document describes the preprocessing pipeline for CODEX images in Aegle. The preprocessing consists of two main stages: Full Image Preprocessing and Patched Image Preprocessing, as implemented in aegle/pipeline.py under the run_pipeline function.","source":"@site/docs/Preprocess/Preprocess.md","sourceDirName":"Preprocess","slug":"/Preprocess/","permalink":"/aegle/docs/Preprocess/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Preprocess/Preprocess.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Preprocess","permalink":"/aegle/docs/category/preprocess"},"next":{"title":"Main","permalink":"/aegle/docs/category/main"}}');var a=s(4848),c=s(8453);const t={sidebar_position:6},l="Preprocess",r={},d=[{value:"A. Full Image Preprocessing",id:"a-full-image-preprocessing",level:2},{value:"Step A1: Initialize <code>CodexImage</code>",id:"step-a1-initialize-codeximage",level:3},{value:"Step A2: Extract Target Channels",id:"step-a2-extract-target-channels",level:3},{value:"Optional: Visualize Whole Sample",id:"optional-visualize-whole-sample",level:3},{value:"B. Patched Image Preprocessing",id:"b-patched-image-preprocessing",level:2},{value:"Step B1: Extend Image",id:"step-b1-extend-image",level:3},{value:"Step B2: Initialize <code>CodexPatches</code> and Save Patches",id:"step-b2-initialize-codexpatches-and-save-patches",level:3},{value:"Optional: Add Disruptions",id:"optional-add-disruptions",level:3},{value:"Optional: Visualize Patches",id:"optional-visualize-patches",level:3}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"preprocess",children:"Preprocess"})}),"\n",(0,a.jsxs)(n.p,{children:["This document describes the preprocessing pipeline for CODEX images in Aegle. The preprocessing consists of two main stages: ",(0,a.jsx)(n.strong,{children:"Full Image Preprocessing"})," and ",(0,a.jsx)(n.strong,{children:"Patched Image Preprocessing"}),", as implemented in ",(0,a.jsx)(n.code,{children:"aegle/pipeline.py"})," under the ",(0,a.jsx)(n.code,{children:"run_pipeline"})," function."]}),"\n",(0,a.jsx)(n.p,{children:"Key outputs include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Patched images with overlapping regions: ",(0,a.jsx)(n.code,{children:"extracted_channel_patches.npy"})," in shape ",(0,a.jsx)(n.code,{children:"(num_patches, patch_size, patch_size, [nucleus, wholecell])"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Metadata for patches: ",(0,a.jsx)(n.code,{children:"patches_metadata.csv"}),".","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"patch_id"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"height"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"width"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"nucleus_mean"}),": the mean intensity of the nucleus channel in the patch"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"nucleus_std"}),": the standard deviation of the nucleus channel in the patch"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"nucleus_non_zero_perc"}),": the percentage of non-zero pixels in the nucleus channel in the patch"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"wholecell_mean"}),": the mean intensity of the wholecell channel in the patch"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"wholecell_std"}),": the standard deviation of the wholecell channel in the patch"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"wholecell_non_zero_perc"}),": the percentage of non-zero pixels in the wholecell channel in the patch"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"is_empty"}),": ",(0,a.jsx)(n.code,{children:"nucleus_non_zero_perc"})," < ",(0,a.jsx)(n.code,{children:"non_zero_perc_threshold"})," (default: 0.05)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"is_noisy"}),": ",(0,a.jsx)(n.code,{children:"nucleus_mean"})," < ",(0,a.jsx)(n.code,{children:"mean_intensity_threshold"})," (default: 1)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"is_bad_patch"}),": ",(0,a.jsx)(n.code,{children:"is_empty"})," | ",(0,a.jsx)(n.code,{children:"is_noisy"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"is_infomative"}),": !",(0,a.jsx)(n.code,{children:"is_bad_patch"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"a-full-image-preprocessing",children:"A. Full Image Preprocessing"}),"\n",(0,a.jsx)(n.p,{children:"This stage prepares the full CODEX image for downstream patch-level processing."}),"\n",(0,a.jsxs)(n.h3,{id:"step-a1-initialize-codeximage",children:["Step A1: Initialize ",(0,a.jsx)(n.code,{children:"CodexImage"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Constructs a ",(0,a.jsx)(n.code,{children:"CodexImage"})," object using configuration parameters and command-line arguments."]}),"\n",(0,a.jsx)(n.li,{children:"Loads the image and its corresponding antibody metadata."}),"\n",(0,a.jsxs)(n.li,{children:["If enabled in the configuration (",(0,a.jsx)(n.code,{children:"data.generate_channel_stats: true"}),"), calculates statistics across channels."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"codex_image = CodexImage(config, args)\ncodex_image.calculate_channel_statistics()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"step-a2-extract-target-channels",children:"Step A2: Extract Target Channels"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Uses configuration to extract biologically relevant channels (e.g. membrane or nucleus markers)."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"codex_image.extract_target_channels()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"optional-visualize-whole-sample",children:"Optional: Visualize Whole Sample"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Saves RGB visualizations of extracted channels to the output directory if ",(0,a.jsx)(n.code,{children:"visualization.visualize_whole_sample"})," is set to ",(0,a.jsx)(n.code,{children:"true"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"save_image_rgb(codex_image.extended_extracted_channel_image, ...)\nsave_image_rgb(codex_image.extracted_channel_image, ...)\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"b-patched-image-preprocessing",children:"B. Patched Image Preprocessing"}),"\n",(0,a.jsx)(n.p,{children:"This stage slices the image into overlapping patches and optionally applies perturbations for robustness testing."}),"\n",(0,a.jsx)(n.h3,{id:"step-b1-extend-image",children:"Step B1: Extend Image"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Pads the original image to ensure that all patches are fully contained within the image bounds."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"codex_image.extend_image()\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"step-b2-initialize-codexpatches-and-save-patches",children:["Step B2: Initialize ",(0,a.jsx)(n.code,{children:"CodexPatches"})," and Save Patches"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Initializes a ",(0,a.jsx)(n.code,{children:"CodexPatches"})," object using the extended ",(0,a.jsx)(n.code,{children:"CodexImage"}),", then generates and saves patches."]}),"\n",(0,a.jsx)(n.li,{children:"Patch metadata is also saved."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"codex_patches = CodexPatches(codex_image, config, args)\ncodex_patches.save_patches(...)\ncodex_patches.save_metadata()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"optional-add-disruptions",children:"Optional: Add Disruptions"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"If configured, adds synthetic noise or perturbations to patches for testing robustness."}),"\n",(0,a.jsxs)(n.li,{children:["Disruption parameters include ",(0,a.jsx)(n.code,{children:"type"})," and ",(0,a.jsx)(n.code,{children:"level"}),", and the disrupted patches can be optionally saved and visualized."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'disruption_type = disruption_config.get("type")\ndisruption_level = disruption_config.get("level", 1)\ncodex_patches.add_disruptions(disruption_type, disruption_level)\ncodex_patches.save_disrupted_patches()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"optional-visualize-patches",children:"Optional: Visualize Patches"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["RGB visualizations of either the original or disrupted patches are saved if ",(0,a.jsx)(n.code,{children:"visualization.visualize_patches"})," is set to ",(0,a.jsx)(n.code,{children:"true"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"save_patches_rgb(codex_patches.extracted_channel_patches, ...)\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"This preprocessing module prepares both the full and patched images for subsequent segmentation and analysis steps. All outputs are saved in a structured format for downstream reproducibility."})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>l});var i=s(6540);const a={},c=i.createContext(a);function t(e){const n=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(c.Provider,{value:n},e.children)}}}]);