"use strict";(self.webpackChunkaegle_docs=self.webpackChunkaegle_docs||[]).push([[232],{7320:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Main/Preprocess","title":"Pipeline Components","description":"This document provides detailed information about the core components of the Main analysis pipeline. The pipeline transforms raw multiplex imaging data into quantified single-cell profiles through a series of carefully orchestrated processing stages.","source":"@site/docs/Main/Preprocess.md","sourceDirName":"Main","slug":"/Main/Preprocess","permalink":"/aegle/docs/Main/Preprocess","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Main/Preprocess.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Outputs","permalink":"/aegle/docs/Main/Outputs"},"next":{"title":"Troubleshooting","permalink":"/aegle/docs/Main/Troubleshooting"}}');var a=s(4848),t=s(8453);const r={sidebar_position:5},l="Pipeline Components",o={},c=[{value:"Pipeline Architecture",id:"pipeline-architecture",level:2},{value:"Phase A: Full Image Processing",id:"phase-a-full-image-processing",level:2},{value:"A1. Image Initialization and Loading",id:"a1-image-initialization-and-loading",level:3},{value:"A2. Channel Statistics Generation",id:"a2-channel-statistics-generation",level:3},{value:"A3. Target Channel Extraction",id:"a3-target-channel-extraction",level:3},{value:"A4. Optional Whole Sample Visualization",id:"a4-optional-whole-sample-visualization",level:3},{value:"Phase B: Patch-Based Processing",id:"phase-b-patch-based-processing",level:2},{value:"B1. Image Extension and Padding",id:"b1-image-extension-and-padding",level:3},{value:"B2. Patch Generation and Organization",id:"b2-patch-generation-and-organization",level:3},{value:"B3. Quality Control and Filtering",id:"b3-quality-control-and-filtering",level:3},{value:"B4. Patch Data Persistence",id:"b4-patch-data-persistence",level:3},{value:"B5. Optional Data Augmentation",id:"b5-optional-data-augmentation",level:3},{value:"B6. Optional Patch Visualization",id:"b6-optional-patch-visualization",level:3},{value:"Integration with Segmentation Pipeline",id:"integration-with-segmentation-pipeline",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Memory Management",id:"memory-management",level:3},{value:"Processing Speed",id:"processing-speed",level:3},{value:"Quality vs. Speed Trade-offs",id:"quality-vs-speed-trade-offs",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"pipeline-components",children:"Pipeline Components"})}),"\n",(0,a.jsx)(n.p,{children:"This document provides detailed information about the core components of the Main analysis pipeline. The pipeline transforms raw multiplex imaging data into quantified single-cell profiles through a series of carefully orchestrated processing stages."}),"\n",(0,a.jsx)(n.h2,{id:"pipeline-architecture",children:"Pipeline Architecture"}),"\n",(0,a.jsx)(n.p,{children:"The Main pipeline consists of two primary processing phases that work together to extract meaningful biological information from large-scale multiplex imaging data:"}),"\n",(0,a.jsx)(n.h2,{id:"phase-a-full-image-processing",children:"Phase A: Full Image Processing"}),"\n",(0,a.jsx)(n.p,{children:"This initial phase handles the complete multiplex image, preparing it for downstream analysis through channel extraction, quality assessment, and optional visualization."}),"\n",(0,a.jsx)(n.h3,{id:"a1-image-initialization-and-loading",children:"A1. Image Initialization and Loading"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Purpose"}),": Establish the foundational image object and load all necessary data"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Process"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"CodexImage Construction"}),": Creates the primary image object using configuration parameters"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multi-channel Loading"}),": Loads the complete QPTIFF/TIFF file with all channels"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Metadata Integration"}),": Associates antibody information with channel indices"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory Management"}),": Optimizes memory usage for large images"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Core initialization\ncodex_image = CodexImage(config, args)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Key Configuration Parameters"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"data.file_name"}),": Path to input QPTIFF file"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"data.antibodies_file"}),": Channel-to-antibody mapping"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"data.image_mpp"}),": Spatial resolution (microns per pixel)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Outputs"}),": Initialized ",(0,a.jsx)(n.code,{children:"CodexImage"})," object with complete channel data"]}),"\n",(0,a.jsx)(n.h3,{id:"a2-channel-statistics-generation",children:"A2. Channel Statistics Generation"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Purpose"}),": Calculate comprehensive statistics for quality control and normalization"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Process"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Intensity Analysis"}),": Computes min, max, mean, median, 95th percentile per channel"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Quality Metrics"}),": Identifies problematic channels (too bright, too dim, empty)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Statistical Summary"}),": Generates channel_stats.csv for downstream use"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Generate statistics when enabled\nif config['data']['generate_channel_stats']:\n    codex_image.calculate_channel_statistics()\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Configuration Control"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"data:\n  generate_channel_stats: true  # Enable comprehensive statistics\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Outputs"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"channel_stats.csv"}),": Per-channel intensity statistics"]}),"\n",(0,a.jsx)(n.li,{children:"Internal statistics for quality control"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"a3-target-channel-extraction",children:"A3. Target Channel Extraction"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Purpose"}),": Select and prepare biologically relevant channels for analysis"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Process"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Channel Selection"}),": Identifies nuclear and wholecell marker channels"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Channel Merging"}),": Combines multiple wholecell channels if specified"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Intensity Optimization"}),": Applies channel-specific preprocessing"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validation"}),": Ensures selected channels contain meaningful signal"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Extract specified channels\ncodex_image.extract_target_channels()\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Configuration Example"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"channels:\n  nuclear_channel: DAPI\n  wholecell_channel: \n    - Pan-Cytokeratin\n    - CD31  # Multiple channels merged\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Outputs"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"extracted_channel_image"}),": Nuclear and wholecell channels ready for segmentation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"extended_extracted_channel_image"}),": Additional context channels"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"a4-optional-whole-sample-visualization",children:"A4. Optional Whole Sample Visualization"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Purpose"}),": Generate overview visualizations for quality assessment"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Process"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"RGB Composition"}),": Creates composite images from selected channels"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Contrast Enhancement"}),": Applies adaptive contrast for better visibility"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Downsampling"}),": Reduces image size for manageable file sizes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multi-scale Output"}),": Generates visualizations at different resolutions"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Generate visualizations when enabled\nif config['visualization']['visualize_whole_sample']:\n    save_image_rgb(codex_image.extracted_channel_image, output_path)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Configuration Options"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"visualization:\n  visualize_whole_sample: true\n  downsample_factor: -1        # Auto-downsample\n  enhance_contrast: true       # Apply contrast enhancement\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Outputs"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"whole_sample_rgb.png"}),": Full sample overview"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"whole_sample_enhanced.png"}),": Contrast-enhanced version"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"phase-b-patch-based-processing",children:"Phase B: Patch-Based Processing"}),"\n",(0,a.jsx)(n.p,{children:"This phase divides the image into manageable patches for scalable analysis, applies quality control, and prepares data for segmentation and cell profiling."}),"\n",(0,a.jsx)(n.h3,{id:"b1-image-extension-and-padding",children:"B1. Image Extension and Padding"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Purpose"}),": Prepare the image for patch extraction by ensuring proper boundaries"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Process"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Boundary Analysis"}),": Calculates required padding based on patch size and overlap"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Smart Padding"}),": Extends image edges using reflection or constant values"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Coordinate Mapping"}),": Maintains spatial relationships between original and extended image"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory Optimization"}),": Minimizes memory footprint while ensuring complete coverage"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Extend image for complete patch coverage\ncodex_image.extend_image()\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Configuration Parameters"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"patching:\n  patch_height: 2000\n  patch_width: 2000\n  overlap: 0.1  # 10% overlap between patches\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Outputs"}),": Extended image array with proper boundaries for patch extraction"]}),"\n",(0,a.jsx)(n.h3,{id:"b2-patch-generation-and-organization",children:"B2. Patch Generation and Organization"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Purpose"}),": Create systematic patch grid for parallel processing"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Process"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Grid Calculation"}),": Determines optimal patch positions with specified overlap"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Patch Extraction"}),": Cuts image into individual patches with consistent dimensions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Coordinate Tracking"}),": Records patch positions for spatial reconstruction"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory Management"}),": Processes patches in batches to control memory usage"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Initialize patch system\ncodex_patches = CodexPatches(codex_image, config, args)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Patch Organization"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Sequential Numbering"}),": Patches numbered 0, 1, 2, ... for consistent reference"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Spatial Indexing"}),": Grid coordinates maintained for spatial analysis"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Overlap Handling"}),": Overlapping regions properly managed for seamless reconstruction"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"b3-quality-control-and-filtering",children:"B3. Quality Control and Filtering"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Purpose"}),": Identify and filter patches suitable for biological analysis"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Process"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Tissue Detection"}),": Identifies patches containing meaningful tissue content"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Noise Assessment"}),": Flags patches with excessive noise or artifacts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Intensity Analysis"}),": Evaluates signal quality in nuclear and wholecell channels"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Metadata Generation"}),": Records quality metrics for each patch"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Generate patch metadata with quality metrics\ncodex_patches.save_metadata()\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Quality Metrics"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"patch_qc:\n  non_zero_perc_threshold: 0.05  # Minimum tissue coverage\n  mean_intensity_threshold: 1    # Minimum signal strength\n  std_intensity_threshold: 1     # Minimum signal variation\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Quality Classifications"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Informative"}),": High-quality patches suitable for analysis"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Empty"}),": Patches with insufficient tissue content"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Noisy"}),": Patches with poor signal quality"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Bad"}),": Patches failing multiple quality criteria"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"b4-patch-data-persistence",children:"B4. Patch Data Persistence"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Purpose"}),": Save processed patches and metadata for downstream analysis"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Process"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Array Serialization"}),": Saves patch arrays in efficient NumPy format"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Metadata Export"}),": Generates CSV files with patch characteristics"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Configuration Backup"}),": Preserves processing parameters for reproducibility"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Index Generation"}),": Creates lookup tables for patch retrieval"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Save patches and associated metadata\ncodex_patches.save_patches()\ncodex_patches.save_metadata()\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Outputs"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"extracted_channel_patches.npy"}),": Processed patch arrays"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"patches_metadata.csv"}),": Quality metrics and spatial information"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"patch_index.json"}),": Spatial indexing information"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"b5-optional-data-augmentation",children:"B5. Optional Data Augmentation"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Purpose"}),": Generate test datasets with controlled perturbations for robustness testing"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Process"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Disruption Selection"}),": Applies specified noise or artifact types"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Controlled Degradation"}),": Adds realistic imaging artifacts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Comparative Analysis"}),": Enables testing of algorithm robustness"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validation Dataset"}),": Creates challenging test cases"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Add controlled disruptions for testing\nif config['testing']['data_disruption']['type']:\n    disruption_type = config['testing']['data_disruption']['type']\n    disruption_level = config['testing']['data_disruption']['level']\n    codex_patches.add_disruptions(disruption_type, disruption_level)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Disruption Types"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Gaussian Noise"}),": Adds random intensity variations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Downsampling"}),": Reduces spatial resolution"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Artifacts"}),": Simulates imaging artifacts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Intensity Scaling"}),": Modifies overall brightness"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Configuration Example"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"testing:\n  data_disruption:\n    type: gaussian      # Type of disruption\n    level: 2           # Intensity level (1-5)\n    save_disrupted_patches: true\n"})}),"\n",(0,a.jsx)(n.h3,{id:"b6-optional-patch-visualization",children:"B6. Optional Patch Visualization"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Purpose"}),": Generate visual outputs for quality assessment and debugging"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Process"}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"RGB Composition"}),": Creates false-color images from selected channels"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Contrast Optimization"}),": Applies adaptive contrast enhancement"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Grid Layout"}),": Organizes patches for systematic review"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Quality Overlay"}),": Highlights patches with quality issues"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Generate patch visualizations\nif config['visualization']['visualize_patches']:\n    save_patches_rgb(codex_patches.extracted_channel_patches, output_dir)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Visualization Options"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"visualization:\n  visualize_patches: true\n  save_all_channel_patches: false  # Save only essential channels\n  enhance_contrast: true\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Outputs"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"patches_rgb/patch-{i}.png"}),": Individual patch visualizations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"patch_grid_overview.png"}),": Complete patch grid overview"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"quality_assessment.png"}),": Quality control visualization"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-segmentation-pipeline",children:"Integration with Segmentation Pipeline"}),"\n",(0,a.jsx)(n.p,{children:"The processed patches from Phase B serve as direct inputs to the segmentation pipeline:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Seamless Handoff"}),": Patch arrays formatted for immediate segmentation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Metadata Preservation"}),": Quality metrics guide segmentation parameters"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Spatial Context"}),": Coordinate information enables result reconstruction"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batch Processing"}),": Patches processed in parallel for efficiency"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Patch Size Optimization"}),": Balance between processing efficiency and memory usage"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Batch Processing"}),": Process patches in groups to control memory consumption"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Garbage Collection"}),": Explicit cleanup of intermediate data structures"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"processing-speed",children:"Processing Speed"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parallel Extraction"}),": Multi-core utilization for patch generation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Efficient Storage"}),": Optimized file formats for fast I/O operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Smart Caching"}),": Avoid redundant computations across patches"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"quality-vs-speed-trade-offs",children:"Quality vs. Speed Trade-offs"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Quality Control Depth"}),": Balance thoroughness with processing speed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Visualization Generation"}),": Optional outputs that significantly impact processing time"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Statistical Analysis"}),": Comprehensive vs. essential metrics"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(n.p,{children:"After completing both processing phases:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Segmentation"}),": Processed patches ready for cell and nucleus segmentation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Quality Review"}),": Assess patch quality distribution and adjust parameters if needed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Downstream Analysis"}),": Proceed to cell profiling and feature extraction"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Result Integration"}),": Combine patch-level results into tissue-level analysis"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This comprehensive preprocessing pipeline ensures that multiplex imaging data is optimally prepared for robust downstream analysis while maintaining spatial relationships and biological context."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var i=s(6540);const a={},t=i.createContext(a);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);