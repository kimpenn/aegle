"use strict";(self.webpackChunkaegle_docs=self.webpackChunkaegle_docs||[]).push([[1520],{7727:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>r});const t=JSON.parse('{"id":"Main/Overview","title":"Overview","description":"This document provides detailed information about the core components of the Main analysis pipeline. The pipeline transforms raw multiplex imaging data into quantified single-cell profiles through a series of carefully orchestrated processing stages.","source":"@site/docs/Main/Overview.md","sourceDirName":"Main","slug":"/Main/Overview","permalink":"/aegle/docs/Main/Overview","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Main/Overview.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Main Processing","permalink":"/aegle/docs/category/main-processing"},"next":{"title":"Usage Guide","permalink":"/aegle/docs/Main/UsageGuide"}}');var s=i(4848),a=i(8453);const l={sidebar_position:1},o="Overview",c={},r=[{value:"Pipeline Architecture",id:"pipeline-architecture",level:2},{value:"Output Structure",id:"output-structure",level:2},{value:"Data Loading and Preprocessing",id:"data-loading-and-preprocessing",level:2},{value:"Load Image and Antibodies Data",id:"load-image-and-antibodies-data",level:3},{value:"Patch-Based Processing",id:"patch-based-processing",level:3},{value:"Optional Patch Perturbations",id:"optional-patch-perturbations",level:3},{value:"Optional Patch Visualizations",id:"optional-patch-visualizations",level:3},{value:"Segmentation and Evaluation",id:"segmentation-and-evaluation",level:2},{value:"Cell Segmentation",id:"cell-segmentation",level:3},{value:"Segmentation Evaluation",id:"segmentation-evaluation",level:3},{value:"Post-Segmentation Analysis",id:"post-segmentation-analysis",level:2},{value:"Cell Profiling",id:"cell-profiling",level:3},{value:"QC Metrics",id:"qc-metrics",level:3},{value:"Visualizations",id:"visualizations",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"overview",children:"Overview"})}),"\n",(0,s.jsx)(n.p,{children:"This document provides detailed information about the core components of the Main analysis pipeline. The pipeline transforms raw multiplex imaging data into quantified single-cell profiles through a series of carefully orchestrated processing stages."}),"\n",(0,s.jsx)(n.h2,{id:"pipeline-architecture",children:"Pipeline Architecture"}),"\n",(0,s.jsx)(n.p,{children:"The Main pipeline consists of two primary processing phases that work together to extract meaningful biological information from large-scale multiplex imaging data:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Aegle Main Pipeline",src:i(8187).A+"",width:"1391",height:"371"})}),"\n",(0,s.jsx)(n.h2,{id:"output-structure",children:"Output Structure"}),"\n",(0,s.jsx)(n.p,{children:"The pipeline generates comprehensive outputs organized in a structured format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"output_directory/\n\u251c\u2500\u2500 cell_profiling/              # Single-cell data\n\u2502   \u251c\u2500\u2500 patch-0-cell_by_marker.csv\n\u2502   \u2514\u2500\u2500 patch-0-cell_metadata.csv\n\u251c\u2500\u2500 extracted_channel_patches.npy   # Processed image patches\n\u251c\u2500\u2500 original_seg_res_batch.pickle   # Raw segmentation results\n\u251c\u2500\u2500 matched_seg_res_batch.pickle    # Processed segmentation results\n\u251c\u2500\u2500 patches_metadata.csv            # Patch-level metadata\n\u251c\u2500\u2500 channel_stats.csv              # Channel statistics\n\u2514\u2500\u2500 copied_config.yaml             # Configuration record\n\u2514\u2500\u2500 seg_evaluation_metrics.pkl     # Segmentation evaluation results\n"})}),"\n",(0,s.jsx)(n.h2,{id:"data-loading-and-preprocessing",children:"Data Loading and Preprocessing"}),"\n",(0,s.jsx)(n.p,{children:"Before segmentation, the pipeline loads the image and the antibodies data and prepare objects for further processing."}),"\n",(0,s.jsx)(n.h3,{id:"load-image-and-antibodies-data",children:"Load Image and Antibodies Data"}),"\n",(0,s.jsxs)(n.p,{children:["This initial phase loads the multiplex image and the antibodies data into the ",(0,s.jsx)(n.code,{children:"CodexImage"})," object."]}),"\n",(0,s.jsxs)(n.p,{children:["Then Calculate channel-level statistics (Min, Median, Max, 95%, Mean, Std Dev) and save them to a file ",(0,s.jsx)(n.code,{children:"channel_stats.csv"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Next, extract the target channels from the image based on the configuration. If more than one wholecell channel is specified, they will be merged into a single channel by taking the maximum intensity projection. The extracted channels are stacked along the third dimension in the order of (nucleus, wholecell) and assigned to the ",(0,s.jsx)(n.code,{children:"extracted_channel_image"})," attribute of the ",(0,s.jsx)(n.code,{children:"CodexImage"})," object."]}),"\n",(0,s.jsx)(n.h3,{id:"patch-based-processing",children:"Patch-Based Processing"}),"\n",(0,s.jsxs)(n.p,{children:["Ideally, we just use ",(0,s.jsx)(n.code,{children:"patching::split_mode"})," as ",(0,s.jsx)(n.code,{children:"full_image"})," and consider the image as a single patch for segmentation. However, sometimes the image is too large to be processed in a single patch, we can use ",(0,s.jsx)(n.code,{children:"patching::split_mode"})," as ",(0,s.jsx)(n.code,{children:"halves"})," or ",(0,s.jsx)(n.code,{children:"quarters"})," to divide the image into manageable patches. I had situation that after spliting, the image is still too large to fit into memory. So we implemented a disk-based patches strategy to handle large images. See ",(0,s.jsx)(n.code,{children:"_extract_patches_from_coordinates"})," in ",(0,s.jsx)(n.code,{children:"codex_patches.py"}),". But we should implment more unit test to make sure the disk-based patches strategy is working as expected."]}),"\n",(0,s.jsxs)(n.p,{children:["On the other hand, we would like to do segmentation on small patches for other purposes, such as patch-level analysis. We can use ",(0,s.jsx)(n.code,{children:"patching::split_mode"})," as ",(0,s.jsx)(n.code,{children:"patches"})," to divide the image into small patches. The ",(0,s.jsx)(n.code,{children:"patching::patch_height"})," and ",(0,s.jsx)(n.code,{children:"patching::patch_width"})," are the height and width of each patch, and the ",(0,s.jsx)(n.code,{children:"patching::overlap"})," is the overlap fraction between adjacent patches. We have a ",(0,s.jsx)(n.a,{href:"https://github.com/kimpenn/aegle_patch_viewer",children:"web app"})," to visualize the patches with the overlap to have intuition about the patches. Two have patches in same shape, we have two steps:(1) extend the image for full patch coverage and (2) generate the patches on the extended image. The patches are saved in the ",(0,s.jsx)(n.code,{children:"CodexPatches"})," object as ",(0,s.jsx)(n.code,{children:"extracted_channel_patches"})," and ",(0,s.jsx)(n.code,{children:"all_channel_patches"})," attributes."]}),"\n",(0,s.jsxs)(n.p,{children:["The metadata of patches are calculated, including patch_id, height, width, nucleus_mean, nucleus_std, nucleus_non_zero_perc, wholecell_mean, wholecell_std, wholecell_non_zero_perc. Config has ",(0,s.jsx)(n.code,{children:"patch_qc"})," section to control the quality control, including"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"non_zero_perc_threshold"}),": Minimum fraction of non-zero pixels required for a patch to be considered valid"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mean_intensity_threshold"}),": Minimum mean intensity for the patch to be considered informative"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std_intensity_threshold"}),': Minimum standard deviation required to avoid marking patches as too "flat"\nCurrently the first two are used. A patch is considered empty if the ',(0,s.jsx)(n.code,{children:"nucleus_non_zero_perc"})," is less than ",(0,s.jsx)(n.code,{children:"non_zero_perc_threshold"})," and considered noisy if the ",(0,s.jsx)(n.code,{children:"nucleus_mean"})," is less than ",(0,s.jsx)(n.code,{children:"mean_intensity_threshold"})," and it is set as ",(0,s.jsx)(n.code,{children:"is_empty"})," and ",(0,s.jsx)(n.code,{children:"is_noisy"})," in ",(0,s.jsx)(n.code,{children:"patches_metadata"}),". Either of them is true, the patch is marked as bad and set as ",(0,s.jsx)(n.code,{children:"is_bad_patch"})," in ",(0,s.jsx)(n.code,{children:"patches_metadata"}),". The patches are marked as informative if they are not bad. Details see ",(0,s.jsx)(n.code,{children:"qc_patch_metadata"})," in ",(0,s.jsx)(n.code,{children:"codex_patches.py"}),". It helps to filter out the patches which are background, artifacts, or just a small part of the tissue. We will only run segmentation on the informative patches."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The matadata is saved as ",(0,s.jsx)(n.code,{children:"patches_metadata"})," attribute of the ",(0,s.jsx)(n.code,{children:"CodexPatches"})," object and saved in the ",(0,s.jsx)(n.code,{children:"patches_metadata.csv"})," file."]}),"\n",(0,s.jsx)(n.h3,{id:"optional-patch-perturbations",children:"Optional Patch Perturbations"}),"\n",(0,s.jsx)(n.p,{children:"To test the robustness of downstream segmentation models, we implment this module to add controlled perturbations to the patches. So that we can benchmarking the segmentation models on different types of data disruptions. It should not be used in the production environment."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"testing::data_disruption::type"})," is None, no perturbations will be added."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"testing::data_disruption::type"})," is ",(0,s.jsx)(n.code,{children:"gaussian"}),", we will add Gaussian noise to the patches. The noise level is controlled by ",(0,s.jsx)(n.code,{children:"testing::data_disruption::level"}),". The noise level is a number between 1 and 5. 1 is the minimal noise level and 5 is the maximal noise level."]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"testing::data_disruption::type"})," is ",(0,s.jsx)(n.code,{children:"downsampling"}),", we will downsample the patches. The downsampling level is controlled by ",(0,s.jsx)(n.code,{children:"testing::data_disruption::level"}),". The downsampling level is a number between 1 and 3. 1 is the minimal downsampling level and 3 is the maximal downsampling level."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We can use ",(0,s.jsx)(n.code,{children:"testing::data_disruption"})," section to control the perturbations. Details see ",(0,s.jsx)(n.code,{children:"add_disruptions"})," in ",(0,s.jsx)(n.code,{children:"codex_patches.py"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"TODO: It might be better to isolate this module from the main pipeline. So that we can use it in the production environment. But we need to make more changes and divide the pipeline into more components such that the output from perturbation module can be integrated into the main pipeline."}),"\n",(0,s.jsx)(n.h3,{id:"optional-patch-visualizations",children:"Optional Patch Visualizations"}),"\n",(0,s.jsx)(n.p,{children:"We generate the visualizations of the patches to help the user to check the quality of the patches and the perturbations."}),"\n",(0,s.jsxs)(n.p,{children:["Notes: Given ",(0,s.jsx)(n.code,{children:"visualization::visualize_patches"})," is True, if ",(0,s.jsx)(n.code,{children:"testing::data_disruption::visualize_disrupted"})," is True, the visualizations will be the disrupted patches. Otherwise, the visualizations will be the original patches."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Visualization Configuration"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'testing:\n  data_disruption:\n    # Disruption type can be "downsampling" or "gaussian"\n    type: gaussian\n    # Intensity level of disruption (1-5, for instance)\n    level: 3\n    # Whether to save the disrupted patches to disk (for debugging/testing)\n    save_disrupted_patches: True\n    # Whether to visualize the disrupted patches\n    visualize_disrupted: False\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Outputs"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"patches_visualizations/good_patches/patch-{i}.png"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"patches_visualizations/bad_patches/patch-{i}.png"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"segmentation-and-evaluation",children:"Segmentation and Evaluation"}),"\n",(0,s.jsxs)(n.p,{children:["This stage covers both ",(0,s.jsx)(n.strong,{children:"segmentation"})," and ",(0,s.jsx)(n.strong,{children:"automated quality assessment"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"cell-segmentation",children:"Cell Segmentation"}),"\n",(0,s.jsxs)(n.p,{children:["This phase performs cell and nucleus segmentation on the informative patches using the DeepCell Mesmer model. The segmentation process identifies individual cells and their corresponding nuclei, enabling downstream single-cell analysis. The ",(0,s.jsx)(n.code,{children:"run_cell_segmentation"})," function in ",(0,s.jsx)(n.code,{children:"segment.py"})," orchestrates the entire segmentation process:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Patch Selection"}),": Only processes patches marked as informative (not empty or noisy) from Phase B"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Model Loading"}),": Loads the pre-trained DeepCell Mesmer model for multiplex segmentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Segmentation Processing"}),": Applies the model to extract cell and nucleus masks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mask Repair"}),": Matches cells to nuclei and repairs segmentation artifacts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Result Storage"}),": Saves segmentation masks and metadata"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["More details see ",(0,s.jsx)(n.a,{href:"/aegle/docs/Main/SegmentationDetails",children:"Segmentation Details"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Segmentation Configuration"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"segmentation:\n  # Path to the DeepCell Mesmer model\n  model_path: /path/to/MultiplexSegmentation\n  # Save segmentation masks as image files\n  save_segmentation_images: true\n  # Save complete segmentation results as pickle\n  save_segmentation_pickle: true\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Outputs"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Segmentation Masks (per patch):","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cell_matched_mask"}),": Matched cell segmentation masks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"nucleus_matched_mask"}),": Matched nucleus segmentation masks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cell_outside_nucleus_mask"}),": Cell regions outside nucleus boundaries"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Metadata:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"patches_metadata.csv"}),": Updated with ",(0,s.jsx)(n.code,{children:"matched_fraction"})," for each patch"]}),"\n",(0,s.jsx)(n.li,{children:"Segmentation quality statistics and matching metrics"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Optional Outputs:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Segmentation mask images (if ",(0,s.jsx)(n.code,{children:"save_segmentation_images: true"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Complete ",(0,s.jsx)(n.code,{children:"CodexPatches"})," pickle file (if ",(0,s.jsx)(n.code,{children:"save_segmentation_pickle: true"}),")"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"segmentation-evaluation",children:"Segmentation Evaluation"}),"\n",(0,s.jsxs)(n.p,{children:["This step is the automated segmentation quality assessment using the ",(0,s.jsx)(n.code,{children:"run_seg_evaluation"})," function implemented in ",(0,s.jsx)(n.code,{children:"evaluation.py"}),". This evaluation system provides comprehensive metrics to assess the quality of cell segmentation results. The evaluation process follows these key steps:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Patch Filtering"}),": Only evaluates informative patches (marked as ",(0,s.jsx)(n.code,{children:"is_informative"})," in metadata)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cell Count Validation"}),": Skips patches with fewer than 20 cells to ensure statistical reliability"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parallel Processing"}),": Uses 2 worker processes for efficient evaluation across multiple patches"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comprehensive Metrics"}),": Calculates 14 different quality metrics for each patch"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Quality Score Generation"}),": Combines metrics into a single quality score using PCA-based model"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["More details see ",(0,s.jsx)(n.a,{href:"/aegle/docs/Main/EvaluationDetails",children:"Evaluation Details"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Evaluation Configuration"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"evaluation:\n  compute_metrics: false\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Outputs"})}),"\n",(0,s.jsxs)(n.p,{children:["The evaluation results are stored in ",(0,s.jsx)(n.code,{children:"codex_patches.seg_evaluation_metrics"})," as a list of dictionaries, where each dictionary contains and saved in the ",(0,s.jsx)(n.code,{children:"seg_evaluation_metrics.pkl"})," file."]}),"\n",(0,s.jsx)(n.h2,{id:"post-segmentation-analysis",children:"Post-Segmentation Analysis"}),"\n",(0,s.jsx)(n.h3,{id:"cell-profiling",children:"Cell Profiling"}),"\n",(0,s.jsx)(n.h3,{id:"qc-metrics",children:"QC Metrics"}),"\n",(0,s.jsx)(n.h3,{id:"visualizations",children:"Visualizations"})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8187:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/agle-main.drawio-eb84fce560ed0f6458f188a2c215087d.png"},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var t=i(6540);const s={},a=t.createContext(s);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);