"use strict";(self.webpackChunkaegle_docs=self.webpackChunkaegle_docs||[]).push([[9041],{5785:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"ExperimentConfiguration/Templates","title":"Templates and Design Tables","description":"This section covers both YAML configuration templates and CSV experiment design tables, which work together to generate experiment-specific configurations. The templates define the structure and defaults, while the design tables specify experiment-specific parameters.","source":"@site/docs/ExperimentConfiguration/Templates.md","sourceDirName":"ExperimentConfiguration","slug":"/ExperimentConfiguration/Templates","permalink":"/aegle/docs/ExperimentConfiguration/Templates","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ExperimentConfiguration/Templates.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Outputs","permalink":"/aegle/docs/ExperimentConfiguration/Outputs"},"next":{"title":"Data Preprocessing","permalink":"/aegle/docs/category/data-preprocessing"}}');var t=i(4848),a=i(8453);const l={sidebar_position:4},r="Templates and Design Tables",c={},o=[{value:"Template Types",id:"template-types",level:2},{value:"Preprocessing Template (<code>preprocess_template.yaml</code>)",id:"preprocessing-template-preprocess_templateyaml",level:3},{value:"Main Template (<code>main_template.yaml</code>)",id:"main-template-main_templateyaml",level:3},{value:"Analysis Template (<code>analysis_template.yaml</code>)",id:"analysis-template-analysis_templateyaml",level:3},{value:"Template Structure and Mapping",id:"template-structure-and-mapping",level:2},{value:"Example Template Structure",id:"example-template-structure",level:3},{value:"CSV to YAML Mapping",id:"csv-to-yaml-mapping",level:3},{value:"Experiment Design Tables (CSV)",id:"experiment-design-tables-csv",level:2},{value:"Design Table Structure",id:"design-table-structure",level:3},{value:"Google Sheet Organization",id:"google-sheet-organization",level:4},{value:"CSV File Structure",id:"csv-file-structure",level:4},{value:"Pipeline-Specific Design Tables",id:"pipeline-specific-design-tables",level:3},{value:"Preprocessing Design Table (<code>preprocess_x.csv</code>)",id:"preprocessing-design-table-preprocess_xcsv",level:4},{value:"Main Design Table (<code>main_x.csv</code>)",id:"main-design-table-main_xcsv",level:4},{value:"Analysis Design Table (<code>analysis_x.csv</code>)",id:"analysis-design-table-analysis_xcsv",level:4},{value:"Design Table Best Practices",id:"design-table-best-practices",level:3},{value:"Column Naming",id:"column-naming",level:4},{value:"Data Format Guidelines",id:"data-format-guidelines",level:4},{value:"Example Design Table Workflow",id:"example-design-table-workflow",level:4},{value:"Customization and Extension",id:"customization-and-extension",level:2},{value:"Adding New Parameters",id:"adding-new-parameters",level:3},{value:"Creating New Experiment Sets",id:"creating-new-experiment-sets",level:3},{value:"Parameter Validation",id:"parameter-validation",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"templates-and-design-tables",children:"Templates and Design Tables"})}),"\n",(0,t.jsx)(n.p,{children:"This section covers both YAML configuration templates and CSV experiment design tables, which work together to generate experiment-specific configurations. The templates define the structure and defaults, while the design tables specify experiment-specific parameters."}),"\n",(0,t.jsx)(n.h2,{id:"template-types",children:"Template Types"}),"\n",(0,t.jsxs)(n.h3,{id:"preprocessing-template-preprocess_templateyaml",children:["Preprocessing Template (",(0,t.jsx)(n.code,{children:"preprocess_template.yaml"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"The preprocessing template handles the initial stages of data processing:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tissue Extraction Parameters"}),": Configure tissue detection and extraction settings"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BF Tools Configuration"}),": Set up BioFormats tools for image reading"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Basic Data Paths"}),": Define input data locations and file structures"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Key Sections"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data"}),": Input file paths and metadata"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"bftools"}),": BioFormats tools configuration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"tissue_extraction"}),": Tissue detection parameters"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"main-template-main_templateyaml",children:["Main Template (",(0,t.jsx)(n.code,{children:"main_template.yaml"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"The main analysis template covers the core image processing and analysis steps:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Image Segmentation Parameters"}),": Configure cell segmentation models and settings"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Patch Extraction Settings"}),": Define image patching and sampling strategies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Visualization Options"}),": Control output visualizations and quality control images"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Quality Control Thresholds"}),": Set filtering criteria for patches and cells"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Key Sections"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data"}),": Image files and antibody definitions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"channels"}),": Nuclear and cell marker channel specifications"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"patching"}),": Image patch extraction parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"visualization"}),": Output visualization settings"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"segmentation"}),": Cell segmentation model configuration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"patch_qc"}),": Quality control thresholds"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"evaluation"}),": Metrics computation settings"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"analysis-template-analysis_templateyaml",children:["Analysis Template (",(0,t.jsx)(n.code,{children:"analysis_template.yaml"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"The analysis template focuses on downstream statistical analysis and visualization:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Downstream Analysis Parameters"}),": Configure statistical analysis methods"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Statistical Computation Settings"}),": Define metrics and statistical tests"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Output Format Configuration"}),": Specify result formats and export options"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Key Sections"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"analysis"}),": Statistical analysis parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"visualization"}),": Advanced plotting and visualization options"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"output"}),": Result export and format specifications"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"template-structure-and-mapping",children:"Template Structure and Mapping"}),"\n",(0,t.jsxs)(n.p,{children:["All templates follow a hierarchical YAML structure that maps directly to the CSV column naming convention using ",(0,t.jsx)(n.code,{children:"::"})," separators."]}),"\n",(0,t.jsx)(n.h3,{id:"example-template-structure",children:"Example Template Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"# Top-level configuration\nexp_id: default\n\n# Data configuration\ndata:\n  file_name: path/to/image.tiff\n  antibodies_file: path/to/antibodies.tsv\n  image_mpp: 0.5\n\n# Channel configuration\nchannels:\n  nuclear_channel: DAPI\n  wholecell_channel: \n    - Pan-Cytokeratin\n\n# Nested configuration example\npatching:\n  split_mode: full_image\n  patch_height: -1\n  patch_width: -1\n  overlap: 0.1\n"})}),"\n",(0,t.jsx)(n.h3,{id:"csv-to-yaml-mapping",children:"CSV to YAML Mapping"}),"\n",(0,t.jsxs)(n.p,{children:["The CSV column names map to YAML structure using the ",(0,t.jsx)(n.code,{children:"::"})," separator:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data::file_name"})," \u2192 ",(0,t.jsx)(n.code,{children:"data.file_name"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"channels::nuclear_channel"})," \u2192 ",(0,t.jsx)(n.code,{children:"channels.nuclear_channel"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"patching::split_mode"})," \u2192 ",(0,t.jsx)(n.code,{children:"patching.split_mode"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"visualization::visualize_patches"})," \u2192 ",(0,t.jsx)(n.code,{children:"visualization.visualize_patches"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"experiment-design-tables-csv",children:"Experiment Design Tables (CSV)"}),"\n",(0,t.jsxs)(n.p,{children:["The CSV design tables are exported from the ",(0,t.jsx)(n.a,{href:"https://docs.google.com/spreadsheets/d/1JcabHe3aobjeRa4V0mNSmC2rnh5jJ3h4_v0jnX2vkOE/edit?usp=sharing",children:"Google Sheet"})," and stored in the ",(0,t.jsx)(n.code,{children:"exps/csvs/"})," directory. Each CSV file corresponds to a specific pipeline component and contains experiment-specific parameters."]}),"\n",(0,t.jsx)(n.h3,{id:"design-table-structure",children:"Design Table Structure"}),"\n",(0,t.jsx)(n.h4,{id:"google-sheet-organization",children:"Google Sheet Organization"}),"\n",(0,t.jsx)(n.p,{children:"The experiments are designed in a shared Google Sheet with separate tabs for each pipeline component:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tab Naming Convention"}),": ",(0,t.jsx)(n.code,{children:"{component}_{set_name}"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"preprocess_ft"})," \u2192 exports to ",(0,t.jsx)(n.code,{children:"preprocess_ft.csv"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"main_ft"})," \u2192 exports to ",(0,t.jsx)(n.code,{children:"main_ft.csv"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"analysis_ft"})," \u2192 exports to ",(0,t.jsx)(n.code,{children:"analysis_ft.csv"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"csv-file-structure",children:"CSV File Structure"}),"\n",(0,t.jsx)(n.p,{children:"Each CSV file contains:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Header Row"}),": Column names using ",(0,t.jsx)(n.code,{children:"::"})," notation for nested parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Rows"}),": One row per experiment with specific parameter values"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Required Column"}),": ",(0,t.jsx)(n.code,{children:"exp_id"})," - unique identifier for each experiment"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"pipeline-specific-design-tables",children:"Pipeline-Specific Design Tables"}),"\n",(0,t.jsxs)(n.h4,{id:"preprocessing-design-table-preprocess_xcsv",children:["Preprocessing Design Table (",(0,t.jsx)(n.code,{children:"preprocess_x.csv"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Configure tissue extraction and preprocessing parameters"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"exp_id"}),": Experiment ID"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data::file_name"}),": Path to the raw image file (.qptiff)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"tissue_extraction::manual_mask_json"}),": Path to manual annotation file. If this file is not provided, the automatic tissue extraction will be used."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"tissue_extraction::visualize"}),": Enable/disable visualization output"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"tissue_extraction::n_tissue"}),": Number of tissue regions to extract for automatic tissue extraction. Set to -1 for manual tissue extraction."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"tissue_extraction::downscale_factor"}),": Downscale factor for the image for automatic tissue extraction. Set to -1 for manual tissue extraction."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"tissue_extraction::min_area"}),": Minimum area of the tissue region for automatic tissue extraction. Set to -1 for manual tissue extraction."]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"main-design-table-main_xcsv",children:["Main Design Table (",(0,t.jsx)(n.code,{children:"main_x.csv"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Configure segmentation, patching, and cell profiling parameters"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"exp_id"}),": Experiment ID"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data::file_name"}),": Path to processed image file (.ome.tiff or .qptiff). If the raw image has multiple tissues, it should be extracted using the tissue region extraction module in the preprocessing step."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data::antibodies_file"}),": Path to antibody definitions (.tsv). It is generated by the antibody data extraction module in the preprocessing step."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data::image_mpp"}),": Microns per pixel for this image. It is determined by PhenoCycler experiment. Most of the time, it is 0.5."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data::generate_channel_stats"}),": Whether to compute and save channel-level statistics (min, max, 95th percentile, etc.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"channels::nuclear_channel"}),": Nuclear marker channel name. Most of the time, it is DAPI."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"channels::wholecell_channel"}),": Comma-separated list of cell marker channels. It is determined by the researcher. If multiple channels are provided, they will be merged into one channel by maximum intensity projection."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"patching::split_mode"}),": Image splitting strategy. It can be ",(0,t.jsx)(n.code,{children:"full_image"}),", ",(0,t.jsx)(n.code,{children:"halves"}),", ",(0,t.jsx)(n.code,{children:"quarters"}),", or ",(0,t.jsx)(n.code,{children:"patches"}),". ",(0,t.jsx)(n.code,{children:"full_image"})," means using the entire image as a single patch. ",(0,t.jsx)(n.code,{children:"halves"})," means splitting the image into two halves vertically or horizontally. ",(0,t.jsx)(n.code,{children:"quarters"})," means splitting the image into four quarters. ",(0,t.jsx)(n.code,{children:"patches"})," means using small patches with overlap for segmentation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"patching::split_direction"}),": Image splitting direction for split_mode ",(0,t.jsx)(n.code,{children:"halves"}),". It can be ",(0,t.jsx)(n.code,{children:"vertical"})," or ",(0,t.jsx)(n.code,{children:"horizontal"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"patching::patch_height"}),": Height of each patch (in pixels) for split_mode ",(0,t.jsx)(n.code,{children:"patches"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"patching::patch_width"}),": Width of each patch (in pixels) for split_mode ",(0,t.jsx)(n.code,{children:"patches"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"patching::overlap"}),": Overlap fraction between adjacent patches (0.1 means 10% overlap) for split_mode ",(0,t.jsx)(n.code,{children:"patches"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"visualization::visualize_whole_sample"}),": (Deprecated in main pipeline) Whole-sample overviews are produced in the preprocess module."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"visualization::downsample_factor"}),": How to downsample the visualization image. -1 means not valid. Other than -1, it should be a positive integer."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"visualization::enhance_contrast"}),": Whether to apply contrast enhancement to the visualization by adaptive histogram equalization."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"visualization::visualize_patches"}),": Whether to save RGB visualizations of all patches"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"visualization::save_all_channel_patches"}),": Whether to save the raw multi-channel patches to disk. By default, it is False in the template to save space."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"visualization::visualize_segmentation"}),": Whether to visualize and save the segmentation mask overlay (after segmentation). This component is disabled in the pipeline to save time."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"patch_qc::non_zero_perc_threshold"}),": Minimum fraction of non-zero pixels required for a patch to be considered valid"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"patch_qc::mean_intensity_threshold"}),": Minimum mean intensity for the patch to be considered informative"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"patch_qc::std_intensity_threshold"}),': Minimum standard deviation required to avoid marking patches as too "flat"']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"segmentation::model_path"}),": Path to segmentation model"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"segmentation::save_segmentation_images"}),": Whether to save segmentation masks as images"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"segmentation::save_segmentation_pickle"}),": Whether to pickle the entire codex_patches object (containing segmentation results, etc.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"segmentation::segmentation_analysis"}),": Whether to run segmentation analysis"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"testing::data_disruption::type"}),": Type of data disruption"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"testing::data_disruption::level"}),": Level of data disruption"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"testing::data_disruption::save_disrupted_patches"}),": Whether to save disrupted patches"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"evaluation::compute_metrics"}),": Whether to compute metrics"]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"analysis-design-table-analysis_xcsv",children:["Analysis Design Table (",(0,t.jsx)(n.code,{children:"analysis_x.csv"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Configure downstream statistical analysis and visualization"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"exp_id"}),": Experiment ID"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"analysis::data_dir"}),": Directory containing the CSV or expression files for this analysis"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"analysis::patch_index"}),": Which patch index to analyze (if you have multiple patches)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"analysis::skip_viz"}),": Whether to skip all plotting steps (for faster processing)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"analysis::clustering_resolution"}),": Resolution parameter used by Leiden clustering"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"analysis::norm_method"}),": Normalization method"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"design-table-best-practices",children:"Design Table Best Practices"}),"\n",(0,t.jsx)(n.h4,{id:"column-naming",children:"Column Naming"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Descriptive Names"}),": Column names should clearly indicate their purpose"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Follow Hierarchy"}),": Use ",(0,t.jsx)(n.code,{children:"::"})," to represent nested YAML structure"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consistent Naming"}),": Maintain consistency across different design tables"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Avoid Spaces"}),": Use underscores instead of spaces in parameter names"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"data-format-guidelines",children:"Data Format Guidelines"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Boolean Values"}),": Use ",(0,t.jsx)(n.code,{children:"TRUE/FALSE"})," (case-insensitive)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lists"}),": Use comma-separated values without spaces after commas"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"File Paths"}),": Use absolute paths for reliability"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Null Values"}),": Use ",(0,t.jsx)(n.code,{children:"None"})," for null/empty values"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Numeric Values"}),": Use plain numbers without quotes"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-design-table-workflow",children:"Example Design Table Workflow"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Design in Google Sheet"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create/edit experiments in the shared Google Sheet"}),"\n",(0,t.jsx)(n.li,{children:"Use separate tabs for different pipeline components"}),"\n",(0,t.jsx)(n.li,{children:"Validate data formats and file paths"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Export to CSV"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Export each tab as a separate CSV file"}),"\n",(0,t.jsxs)(n.li,{children:["Save to ",(0,t.jsx)(n.code,{children:"exps/csvs/"})," with appropriate filename"]}),"\n",(0,t.jsx)(n.li,{children:"Ensure proper encoding (UTF-8)"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Generate Configurations"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Update ",(0,t.jsx)(n.code,{children:"config_generator.py"})," with correct experiment set name"]}),"\n",(0,t.jsx)(n.li,{children:"Run generator to create YAML configurations"}),"\n",(0,t.jsx)(n.li,{children:"Validate generated files before pipeline execution"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"customization-and-extension",children:"Customization and Extension"}),"\n",(0,t.jsx)(n.h3,{id:"adding-new-parameters",children:"Adding New Parameters"}),"\n",(0,t.jsx)(n.p,{children:"To add new parameters to the system:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Update Template File"}),": Add the new parameter with default value in the appropriate YAML template"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Update Design Table"}),": Add corresponding column in the Google Sheet and export to CSV"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Update Generator Logic"}),": Add type conversion logic in ",(0,t.jsx)(n.code,{children:"config_generator.py"})," if needed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test Generation"}),": Verify the parameter is correctly processed and appears in generated configs"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"creating-new-experiment-sets",children:"Creating New Experiment Sets"}),"\n",(0,t.jsx)(n.p,{children:"To create a new experiment set:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Create New Tab"}),": Add a new tab in the Google Sheet following naming convention ",(0,t.jsx)(n.code,{children:"{component}_{set_name}"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Design Experiments"}),": Add experiment rows with appropriate parameters\u201c"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Export CSV"}),": Save the tab as ",(0,t.jsx)(n.code,{children:"{set_name}.csv"})," in the ",(0,t.jsx)(n.code,{children:"exps/csvs/"})," directory"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Update Generator"}),": Set ",(0,t.jsx)(n.code,{children:'experiment_set_name = "{set_name}"'})," in ",(0,t.jsx)(n.code,{children:"config_generator.py"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Generate Configs"}),": Run the generator to create configuration files"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"parameter-validation",children:"Parameter Validation"}),"\n",(0,t.jsx)(n.p,{children:"Templates serve as validation references for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Required Parameters"}),": Ensure all necessary parameters are present"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Default Values"}),": Provide fallback values for optional parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Structure Validation"}),": Maintain consistent YAML structure across experiments"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var s=i(6540);const t={},a=s.createContext(t);function l(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);